#!/usr/bin/env python3

# ---------------------------------------------------------------------
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# Original Author: Raheman Vaiya
# ---------------------------------------------------------------------

# Consumes cfg.opts and generates cfg.c and cfg.h which provide a function for
# parsing a config file and populating a generated c struct. The generated code
# is sufficiently clean that it can then be tweaked by hand if necessary.

# cfg.opts should consist of lines of the following form:
#
# <option/field name> <type (must be string, int, or double)> <default val>

import sys
import re

h_template = '''//GENERATED BY %s.

#ifndef _CFG_H_
#define _CFG_H_

struct cfg {
{struct_fields}
};

struct cfg* parse_cfg(const char *fname);

#endif
''' % sys.argv[0]

c_template = r'''//GENERATED BY {script}

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "{header_file}"

static int kvp(char *line, char **key, char **val) {
  *key = NULL;
  *val = NULL;
  
  for(;*line != '\0';line++) {
    if(*line != ' ' && !*key)
      *key = line;
    
    if(*line == ':' && !*val) {
      *line++ = '\0';
      for(;isspace(*line);line++);
      *val = line;
    }
  }
  
  if(*(line - 1) == '\n')
    *(line - 1) = '\0';
  
  if(!(*val && *key))
    return -1;
  
  return 0;
}

struct cfg* parse_cfg(const char *fname) {
    char *line = NULL;
    size_t n = 0, ln = 0;
    struct cfg *cfg = malloc(sizeof(struct cfg));

{field_init}

    FILE *fp = fopen(fname, "r");
    if(!fp) return cfg; //Return defaults if no config file xists..
    while(getline(&line, &n, fp) != -1) {
        ln++;
        char *key, *val;
        if(kvp(line, &key, &val)) {
            fprintf(stderr, "Invalid entry in %s at line %lu.\n", fname, ln);
            exit(1);
        }

{field_checks}

        free(line);
        line = NULL;
        n = 0;
    }

    return cfg;
}
'''.replace('{script}', sys.argv[0])


conversion_map = {
    'string': 'strdup',
    'int': 'atoi',
    'double': 'atof',
}


def generate_h(options):
    struct_fields = ''
    for fld, typ, _ in options:
        struct_fields += '    %s %s;\n' % ('char*' if typ ==
                                           'string' else typ, fld)

    return h_template.replace('{struct_fields}', struct_fields.rstrip())


def generate_c(options, header_file):
    field_init = ''
    for fld, typ, default in options:
        field_init += '    cfg->%s = %s;\n' % (fld, default)

    field_checks = ''

    cond = 'if'
    for i, t in enumerate(options):
        fld = t[0]
        typ = t[1]
        field_checks += '''\
        %s(!strcmp(key, "%s"))
            cfg->%s = %s(val);\n''' % (cond, fld, fld, conversion_map[typ])
        cond = 'else if'

    return c_template\
        .replace('{field_checks}', field_checks.rstrip())\
        .replace('{field_init}', field_init.rstrip())\
        .replace('{header_file}', header_file)


def read_opts(fname):
    ln = 0
    opts = []
    for l in open(fname, 'r').read().rstrip().split('\n'):
        ln += 1
        if l == '':
            continue
        opt = l.split(maxsplit=2)
        l = re.sub(' *//.*', '', l)  # Strip comments
        if len(opt) != 3 or not conversion_map.get(opt[1]):
            print(
                "ERROR: line %d must be of format <field name> <type> <default value>" % ln)
            exit(1)

        opts.append(opt)

    return opts


opts = read_opts('cfg.opts')

header = generate_h(opts)
c = generate_c(opts, 'cfg.h')

open('cfg.c', 'w').write(c)
open('cfg.h', 'w').write(header)
print("Successfully generated cfg.h and cfg.c")
